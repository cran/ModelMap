\name{model.diagnostics}
\alias{model.diagnostics}


\title{ Model Predictions and Diagnostics }
\description{
  Takes model object and makes predictions, runs model diagnostics, and creates graphs and tables of the results.  
}
\usage{
model.diagnostics(model.obj = NULL, qdata.trainfn = NULL, qdata.testfn = NULL, folder = NULL, MODELfn = NULL, response.name = NULL, unique.rowname = NULL, seed = NULL, prediction.type=NULL, MODELpredfn = NULL, na.action = "na.omit", v.fold = 10, device.type = NULL, DIAGNOSTICfn = NULL, jpeg.res = 72, device.width = 7,  device.height = 7, cex=par()$cex, req.sens, req.spec, FPC, FNC)
}

\arguments{

  \item{model.obj}{ \code{R} model object.  The model object to use for prediction, if the model has been previously created.  The model object must be of type RF or SGB.  (Eventually planned to include "GAM".)  If \code{NULL} (the default), a model is generated of type specified by the argument \code{model.type}.  }

  \item{qdata.trainfn}{String.  The name (full path or base name with path specified by \code{folder}) of the training data file used for building the model (file should include columns for both response and predictor variables).  The file must be a comma-delimited file \code{*.csv} with column headings. \code{qdata.trainfn} can also be an \code{R} dataframe. If predictions will be made (\code{predict = TRUE} or \code{map=TRUE}) the predictor column headers must match the names of the raster layer files, or a \code{rastLUT} must be provided to match predictor columns to the appropriate raster and band.  If \code{qdata.trainfn = NULL} (the default), a GUI interface prompts user to browse to the training data file.  }

  \item{qdata.testfn}{String.  The name (full path or base name with path specified by \code{folder}) of the independent data set for testing (validating) the model's predictions.  The file must be a comma-delimited file \code{".csv"} with column headings and the column headings must be the same as those in the training data file.  \code{qdata.testfn} can also be an \code{R} dataframe. If \code{qdata.testfn = NULL} (default), a GUI interface asks user if there is a test set available, then prompts user to browse to the test data file.  If no test set is desired (for example, cross-fold validation will be performed, or for RF models, Out-Of-Bag estimation, set \code{qdata.testfn = FALSE}. If no test set is given, and \code{qdata.testfn} is not set to \code{FALSE}, the GUI interface asks if a proportion of the data should be set aside as an independent test set.  If this is desired, the user will be prompted to specify the proportion to set aside as test data, and two new data files will be generated in the out put folder.  The new file names will be the original data file name with \code{"_train"} and \code{"_test"} appended to the end of the file names.}

  \item{folder}{ String.  The folder used for all output from predictions and/or maps.  Do not add ending slash to path string.  If \code{folder = NULL} (default), a GUI interface prompts user to browse to a folder.  To use the working directory, specify \code{folder = getwd()}.}

  \item{MODELfn}{ String.  The file name to use to save the generated model object.  If \code{MODELfn = NULL} (the default), a default name is generated by pasting \code{model.type_response.type_response.name}. If the other output filenames are left unspecified, \code{MODELfn} will be used as the basic name to generate other output filenames. The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by \code{folder}.}

  \item{response.name}{ String.  The name of the response variable used to build the model. The \code{response.name} must be column name from the training/test data files. If the \code{model.obj} was constructed in \code{ModelMap} with the \code{model.build()} function, then the \code{model.diagnostics()} can extract the \code{response.name} from the \code{model.obj}. If the model was constructed outside of \code{ModelMap} the you may need to specify the \code{response.name}. In  particular, if a SGB model was constructed with the aid of Elith's code, it is neccessary to specify the \code{response.name} argument, as all models constructed with this code are given a response name of \code{"y.data"}. If the \code{response.name} argument differs from the response name in the \code{model.obj}, the specified argument is giver preference, and a warning generated.}

  \item{unique.rowname}{ String.  The name of the unique identifier used to identify each row in the training data.  If \code{unique.rowname = NULL}, a GUI interface prompts user to select a variable from the list of column names from the training data file.  If \code{unique.rowname = FALSE}, a variable is generated of numbers from \code{1} to \code{nrow(qdata)} to index each row. }

  \item{seed}{ Integer.  The number used to initialize randomization to build RF or SGB models.  If you want to produce the same model later, use the same seed.  If \code{seed = NULL} (the default), a new seed is created each run. }

  \item{prediction.type}{ String. Prediction type.  \code{"TEST"}, \code{"CV"}, \code{"OOB"} or \code{"TRAIN"}.  If \code{predict = "TEST"}, validation predictions will be made on the test set provided by \code{qdata.testfn}.  If \code{predict = "CV"}, cross validation will be used on the training data provided by \code{qdata.trainfn}. If \code{model.obj} is a Random Forest model and \code{predict = "OOB"} the Out-of-Bag predictions will be calculated on the training data. If \code{model.obj} is a Stochastic Gradient Boosting model and \code{predict = "TRAIN"} the predictions will be calculated on the training data, but these predictions should be used with caution as this will lead to over optimistic estimates of model quality. A \code{*.csv} file of the unique id, observed, and predicted values is generated and put in the specified (or default) folder.}

  \item{MODELpredfn}{ String.  Model validation.  A character string used to construct the output file names for the validation diagnostics, for example the prediction \code{*.csv} file, and the graphics \code{*.jpg}, \code{*.pdf} and \code{*.ps} files.  The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by \code{folder}. If \code{MODELpredfn = NULL} (the default), a default name is created by pasting \code{modelfn} and \code{"_pred"}.}

  \item{na.action}{String.  Model validation.  Specifies the action to take if there are \code{NA} values in the prediction data or if there is a level or class of a ctegorical predictor variable in the validation test set or the production (mapping) data set, but not in the training data set.  There are 2 options: (1) \code{na.action = "na.omit"} (the default) where any data point or pixel with any new levels for any of the factored predictors is returned as \code{-9999} (the \code{NODATA} value); (2) \code{na.action = "na.roughfix"} where a missing categorical predictor for a data point or pixel is replaced with the most common category for that predictor, and a missing continuous predictor is replaced with the median for that predictor.   }

  \item{v.fold}{ Integer (or logical \code{FALSE}).  Model validation.  The number of cross validation folds to use when making validation predictions on the training data.  Only used if  \code{prediction.type = "CV"}.}

  \item{device.type}{ String or vector of strings.  Model validation.  One or more device types for graphical output from model validation diagnostics. 

Current choices:

\tabular{lllll}{
	  \tab \tab \tab \code{"default"} \tab default graphics device\cr
	  \tab \tab \tab \code{"jpeg"} \tab \code{*.jpg} files\cr
	  \tab \tab \tab \code{"pdf"} \tab \code{*.pdf} files\cr
	  \tab \tab \tab \code{"postscript"} \tab \code{*.ps} files\cr
	  \tab \tab \tab \code{"win.metafile"} \tab \code{*.emf} files }
 }

  \item{DIAGNOSTICfn}{ String.  Model validation.  Name used as base to create names for output files from model validation diagnostics.  The filename can be the full path, or it can be the simple basename, in which case the output will be to the folder specified by \code{folder}.  Defaults to \code{DIAGNOSTICfn = MODELfn} followed by the appropriate suffixes (i.e. \code{".csv"}, \code{".jpg"}, etc...). }

  \item{jpeg.res}{ Integer.  Model validation.  Pixels per inch for jpeg plots.  The default is 72dpi, good for on screen viewing. For printing, suggested setting is 300dpi. }

  \item{device.width}{ Integer.  Model validation.  The device width for diagnostic plots in inches. }

  \item{device.height}{ Integer.  Model validation.  The device height for diagnostic plots in inches. }

  \item{cex}{ Integer.  Model validation.  The cex for diagnostic plots. }

  \item{req.sens}{ Numeric.  Model validation.  The required sensitivity for threshold optimization for binary response model evaluation. }

  \item{req.spec}{ Numeric.  Model validation.  The required specificity for threshold optimization for binary response model evaluation. }

  \item{FPC}{ Numeric.  Model validation.  The False Positive Cost for threshold optimization for binary response model evaluation. }

  \item{FNC}{ Numeric.  Model validation.  The False Negative Cost for threshold optimization for binary response model evaluation. }

}
\details{

\code{model.diagnostics()}takes model object and makes predictions, runs model diagnostics, and creates graphs and tables of the results.

\code{model.diagnostics()} can be run in a traditional R command mode, where all arguments are specified in the function call.  However it can also be used in a full push button mode, where you type in the simple command \code{model.map()}, and GUI pop up windows will ask questions about the type of model, the file locations of the data, etc...

When running \code{model.map()} on non-Windows platforms, file names and folders need to be specified in the argument list, but other pushbutton selections are handled by the \code{select.list()} function, which is platform independent. 

Diagnostic predictions are made my one of four methods, and a text file is generated consisting of three collumns: Observation ID, observed values and predicted values. If \code{predition.type = "CV")} a forth collumn indicates which cross-fold each observation fell into. 

A variable importance graph is made. 

If \code{response.type = "binary"}, a summary graph is made using the \code{PresenceAbsence} package and a \code{*.csv} spreadsheets are created of optimized thresholds by several methods with their associated error statistics, and predicted prevalence.

If \code{response.type = "continuous"} a scatterplot of observed vs.  predicted is created with a simple linear regression line.  The graph is labeled with slope and intercept of this line as well as Pearson's and Spearman's correlation coefficients.

}
\value{

The function will return a dataframe of the row ID, and the Observed and predicted values. If \code{prediction.type = "CV"} the dataframe also includes a collumn indicating which cross-validation fold each datapoint was in.

}
\references{ 
Breiman, L. (2001) Random Forests. Machine Learning, 45:5-32.

Elith, J., Leathwick, J. R. and Hastie, T. (2008). A working guide to boosted regression trees. Journal of Animal Ecology. 77:802-813.

Friedman, J.H. (2001). Greedy function approximation: a gradient boosting machine. Ann. Stat., 29(5):1189-1232.

Friedman, J.H. (2002). Stochastic gradient boosting. Comput. Stat. Data An., 38(4):367-378.

Liaw, A. and  Wiener, M. (2002). Classification and Regression by randomForest. R News 2(3), 18--22.

Ridgeway, G., (1999). The state of boosting. Comp. Sci. Stat. 31:172-181
 }

\author{ Elizabeth Freeman and Tracey Frescino }
\note{ 
}
\seealso{ \code{\link{get.test}}, \code{\link{model.build}}, \code{\link{model.mapmake}}}
\examples{
###########################################################################
############################# Run this set up code: #######################
###########################################################################

# set seed:
seed=38

# Define training and test files:

qdata.trainfn = system.file("external", "helpexamples","DATATRAIN.csv", package = "ModelMap")
qdata.testfn = system.file("external", "helpexamples","DATATEST.csv", package = "ModelMap")

# Define folder for all output:
folder=getwd()	


###########################################################################
############## Pick one of the following sets of definitions: #############
###########################################################################


########## Continuous Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_Bio_TC"				

#predictors:
predList=c("TCB","TCG","TCW")	

#define which predictors are categorical:
predFactor=FALSE	

# Response name and type:
response.name="BIO"
response.type="continuous"


########## binary Response, Continuous Predictors ############

#file name to store model:
MODELfn="RF_CONIFTYP_TC"				

#predictors:
predList=c("TCB","TCG","TCW")		

#define which predictors are categorical:
predFactor=FALSE

# Response name and type:
response.name="CONIFTYP"

# This variable is 1 if a conifer or mixed conifer type is present, 
# otherwise 0.

response.type="binary"


########## Continuous Response, Categorical Predictors ############

# In this example, NLCD is a categorical predictor.
#
# You must decide what you want to happen if there are categories
# present in the data to be predicted (either the validation/test set
# or in the image file) that were not present in the original training data.
# Choices:
#       na.action = "na.omit"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will be
#                    returned as NA.
#       na.action = "na.roughfix"
#                    Any validation datapoint or image pixel with a value for any
#                    categorical predictor not found in the training data will have
#                    the most common category for that predictor substituted,
#                    and the a prediction will be made.

# You must also let R know which of the predictors are categorical, in other
# words, which ones R needs to treat as factors.
# This vector must be a subset of the predictors given in predList

#file name to store model:
MODELfn="RF_BIO_TCandNLCD"			

#predictors:
predList=c("TCB","TCG","TCW","NLCD")

#define which predictors are categorical:
predFactor=c("NLCD")

# Response name and type:
response.name="BIO"
response.type="continuous"



###########################################################################
########################### build model: ##################################
###########################################################################


### create model ###

model.obj = model.build( model.type="RF",
                       qdata.trainfn=qdata.trainfn,
                       folder=folder,		
                       MODELfn=MODELfn,
                       predList=predList,
                       predFactor=predFactor,
                       response.name=response.name,
                       response.type=response.type,
                       seed=seed
)

###########################################################################
#### Then Run this code make validation predictions and diagnostics: ######
###########################################################################

### Define identifier for individual training and test data points ###

unique.rowname="ID"


### for Out-of-Bag predictions ###

MODELpredfn<-paste(MODELfn,"_OOB",sep="")
PRED.OOB<-model.diagnostics( 	model.obj=model.obj,
				qdata.trainfn=qdata.trainfn,
                   		folder=folder,		
                  	 	unique.rowname=unique.rowname,
                	# Model Validation Arguments
                   		prediction.type="OOB",
                   		MODELpredfn=MODELpredfn,
                   		device.type=c("default","jpeg","pdf"),	
                   		na.action="na.roughfix"
)
PRED.OOB

### for Cross-Validation predictions ###

MODELpredfn<-paste(MODELfn,"_CV",sep="")
PRED.CV<-model.diagnostics( 	model.obj=model.obj,
                   		qdata.trainfn=qdata.trainfn,
                   		folder=folder,		
                   		unique.rowname=unique.rowname,
                   		seed=seed,
                	# Model Validation Arguments
                   		prediction.type="CV",
                   		MODELpredfn=MODELpredfn,
                   		device.type=c("default","jpeg","pdf"),	
                   		v.fold=10,
                   		na.action="na.roughfix"
)
PRED.CV

### for Independant Test Set predictions ###

MODELpredfn<-paste(MODELfn,"_TEST",sep="")
PRED.TEST<-model.diagnostics( 	model.obj=model.obj,
                   		qdata.testfn=qdata.testfn,
                   		folder=folder,		
                   		unique.rowname=unique.rowname,
                	# Model Validation Arguments
                   		prediction.type="TEST",
                   		MODELpredfn=MODELpredfn,
                   		device.type=c("default","jpeg","pdf"),	
                   		na.action="na.roughfix"
)
PRED.TEST

}

\keyword{ models }

